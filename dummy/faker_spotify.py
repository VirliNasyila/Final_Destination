import os
import random

import spotipy
from dotenv import load_dotenv
from faker import Faker
from spotipy.oauth2 import SpotifyClientCredentials

load_dotenv()

# --- KONFIGURASI ---
CLIENT_ID = os.getenv("SPOTIFY_CLIENT_ID")
CLIENT_SECRET = os.getenv("SPOTIFY_CLIENT_SECRET")
OUTPUT_FILE = "../database/02_dml_spotify_random.sql"
TOTAL_SONGS_WANTED = 50

# --- INIT ---
sp = spotipy.Spotify(
    auth_manager=SpotifyClientCredentials(
        client_id=CLIENT_ID, client_secret=CLIENT_SECRET
    )
)
fake = Faker("id_ID")


def escape_sql(text):
    if text is None:
        return "NULL"
    # Potong text jika kepanjangan sesuai limit VARCHAR DDL
    text_str = str(text).replace("'", "''")
    return "'" + text_str + "'"


def get_safe_date(date_str):
    # 1. Cek jika kosong
    if not date_str or str(date_str).strip() == "":
        return "2020-01-01"

    parts = str(date_str).split("-")

    # 2. Cek Tahun 0000 (Penyebab Error)
    if parts[0] == "0000":
        return "2020-01-01"

    # 3. Format YYYY -> YYYY-01-01
    if len(parts) == 1:
        return f"{parts[0]}-01-01"

    # 4. Format YYYY-MM -> YYYY-MM-01
    if len(parts) == 2:
        return f"{parts[0]}-{parts[1]}-01"

    # 5. Kembalikan aslinya jika sudah YYYY-MM-DD
    return date_str


def map_collection_type(spotify_type):
    # Mapping agar sesuai CONSTRAINT CHECK (Album, EP, Single, Compilation)
    st = spotify_type.lower()
    if "album" in st:
        return "Album"
    if "single" in st:
        return "Single"
    if "compilation" in st:
        return "Compilation"
    return "Compilation"  # Default aman untuk 'appears_on' dll


def generate_data_safe():
    sql_statements = []

    # --- HEADER ---
    sql_statements.append("-- Script Generated by Python Faker")
    
    # CLEANUP DATA LAMA (Hati-hati, ini menghapus semua data)
    sql_statements.append(
        "TRUNCATE TABLE USERS, ARTISTS, GENRES, COLLECTIONS, SONGS, PLAYLISTS, RELEASES, COLLECTIONS_SONGS, CREATE_SONGS, SONGS_GENRES, FOLLOW_ARTISTS, FOLLOW_USERS, LISTENS, LIKE_SONGS, REVIEWS, RATE_SONGS, TOURS, ARTISTS_TOURS, SOCIALS, COLLECTION_LIBRARY, PL_LIBRARY, BLOCK_USERS, BLOCKLIST_ARTISTS, LIKE_REVIEWS RESTART IDENTITY CASCADE;"
    )

    print("ðŸ”Ž Mencari lagu random...")
    collected_tracks = []

    # Loop cari lagu sampai target tercapai
    while len(collected_tracks) < TOTAL_SONGS_WANTED:
        search_char = random.choice(["qwertyuiopasdfghjklzxcvbnm"])
        offset_val = random.randint(0, 100)
        try:
            results = sp.search(
                q=search_char, type="track", limit=50, offset=offset_val
            )
            items = results["tracks"]["items"]
            if items:
                collected_tracks.extend(items)
        except:
            continue
            
        # Hapus duplikat
        seen = set()
        unique = []
        for t in collected_tracks:
            if t['id'] not in seen:
                unique.append(t)
                seen.add(t['id'])
        collected_tracks = unique

    collected_tracks = collected_tracks[:TOTAL_SONGS_WANTED]

    # Cache ID
    artist_map = {}
    album_map = {}
    genre_map = {}

    # Counter ID Manual
    ids = {"users": 1, "artists": 1, "genres": 1, "collections": 1, "songs": 1}

    # ==========================================
    # PART 1: DATA MASTER
    # ==========================================
    
    # 1. USERS
    print("Generating Users...")
    for _ in range(15):
        u_name = fake.user_name()
        email = f"{u_name}_{ids['users']}@example.com" 
        sql = f"INSERT INTO USERS (USER_ID, USERNAME, USER_EMAIL, PW_HASH) VALUES ({ids['users']}, {escape_sql(u_name)}, {escape_sql(email)}, 'password123safe');"
        sql_statements.append(sql)
        ids["users"] += 1

    # 2. PROSES LAGU
    print("Processing Songs...")
    for track in collected_tracks:
        if not track:
            continue

        # --- ARTIST ---
        sp_artist = track["artists"][0]
        sp_artist_id = sp_artist["id"]
        db_artist_id = artist_map.get(sp_artist_id)

        if not db_artist_id:
            try:
                full_artist = sp.artist(sp_artist_id)
            except:
                continue

            db_artist_id = ids["artists"]
            artist_map[sp_artist_id] = db_artist_id

            name = full_artist["name"][:250] 
            pfp = full_artist["images"][0]["url"] if full_artist["images"] else ""
            art_email = f"artist{db_artist_id}@label.com"

            sql = f"INSERT INTO ARTISTS (ARTIST_ID, ARTIST_NAME, ARTIST_PFP, MONTHLY_LISTENER_COUNT, ARTIST_EMAIL) VALUES ({db_artist_id}, {escape_sql(name)}, {escape_sql(pfp)}, {full_artist['followers']['total']}, {escape_sql(art_email)}) ON CONFLICT DO NOTHING;"
            sql_statements.append(sql)
            ids["artists"] += 1

            # Genre
            for g_name in full_artist["genres"]:
                if g_name not in genre_map:
                    g_id = ids["genres"]
                    genre_map[g_name] = g_id
                    sql_g = f"INSERT INTO GENRES (GENRE_ID, GENRE_NAME) VALUES ({g_id}, {escape_sql(g_name)}) ON CONFLICT DO NOTHING;"
                    sql_statements.append(sql_g)
                    ids["genres"] += 1

        # --- ALBUM / COLLECTION ---
        sp_album = track["album"]
        sp_album_id = sp_album["id"]
        db_album_id = album_map.get(sp_album_id)

        if not db_album_id:
            db_album_id = ids["collections"]
            album_map[sp_album_id] = db_album_id

            title = sp_album["name"][:250]
            c_type = map_collection_type(sp_album["album_type"])
            date = get_safe_date(sp_album["release_date"])
            cover = sp_album["images"][0]["url"] if sp_album["images"] else ""

            sql = f"INSERT INTO COLLECTIONS (COLLECTION_ID, COLLECTION_TITLE, COLLECTION_TYPE, COLLECTION_RELEASE_DATE, COLLECTION_COVER) VALUES ({db_album_id}, {escape_sql(title)}, {escape_sql(c_type)}, {escape_sql(date)}, {escape_sql(cover)}) ON CONFLICT DO NOTHING;"
            sql_statements.append(sql)

            # Releases
            sql_rel = f"INSERT INTO RELEASES (ARTIST_ID, COLLECTION_ID) VALUES ({db_artist_id}, {db_album_id}) ON CONFLICT DO NOTHING;"
            sql_statements.append(sql_rel)
            ids["collections"] += 1

        # --- SONG ---
        db_song_id = ids["songs"]
        title = track["name"][:250]

        duration = int(track["duration_ms"] / 1000)
        if duration < 1:
            duration = 1

        file_path = track["preview_url"] if track["preview_url"] else "/default.mp3"
        pop = track["popularity"]
        date = get_safe_date(track["album"]["release_date"])

        val = round(random.random(), 3)
        acoust = round(random.random(), 3)
        dance = round(random.random(), 3)
        energy = round(random.random(), 3)

        sql = f"""INSERT INTO SONGS (SONG_ID, SONG_TITLE, SONG_DURATION, SONG_FILE, POPULARITY, VALENCE, ACCOUSTICNESS, DANCEABILITY, ENERGY, SONG_RELEASE_DATE) VALUES ({db_song_id}, {escape_sql(title)}, {duration}, {escape_sql(file_path)}, {pop}, {val}, {acoust}, {dance}, {energy}, {escape_sql(date)}) ON CONFLICT DO NOTHING;"""
        sql_statements.append(sql)

        # RELASI SONG
        disc = track["disc_number"]
        tr_no = track["track_number"]
        sql_cs = f"INSERT INTO COLLECTIONS_SONGS (COLLECTION_ID, SONG_ID, NOMOR_DISC, NOMOR_TRACK) VALUES ({db_album_id}, {db_song_id}, {disc}, {tr_no}) ON CONFLICT DO NOTHING;"
        sql_statements.append(sql_cs)

        sql_cr = f"INSERT INTO CREATE_SONGS (ARTIST_ID, SONG_ID) VALUES ({db_artist_id}, {db_song_id}) ON CONFLICT DO NOTHING;"
        sql_statements.append(sql_cr)

        ids["songs"] += 1

    # ==========================================
    # --- PART 2: GENERATE DATA TRANSAKSI ---
    # ==========================================
    print("Generating Transaction Data (Playlists, Likes, Listens)...")

    # Range ID yang valid
    valid_users = list(range(1, ids["users"]))
    valid_songs = list(range(1, ids["songs"]))
    valid_artists = list(range(1, ids["artists"]))
    valid_collections = list(range(1, ids["collections"]))
    valid_genres = list(range(1, ids["genres"]))

    # 4. SONGS_GENRES
    for s_id in valid_songs:
        if not valid_genres:
            break
        picked_genres = random.sample(
            valid_genres, k=random.randint(1, min(3, len(valid_genres)))
        )
        for g_id in picked_genres:
            sql = f"INSERT INTO SONGS_GENRES (SONG_ID, GENRE_ID) VALUES ({s_id}, {g_id}) ON CONFLICT DO NOTHING;"
            sql_statements.append(sql)

    # 5. PLAYLISTS & ADD_SONGS_PLAYLISTS
    # >>> UPDATE: Menambahkan kolom ISONPROFILE, ISCOLLABORATIVE, dan DATE_CREATED
    playlist_id_counter = 1
    for u_id in valid_users:
        for _ in range(random.randint(1, 3)):
            pl_title = fake.sentence(nb_words=3).replace(".", "") 
            desc = fake.sentence(nb_words=10)
            
            # Generate nilai boolean dan tanggal
            is_public = random.choice(["TRUE", "FALSE"])
            is_collab = random.choice(["TRUE", "FALSE"])
            on_profile = random.choice(["TRUE", "FALSE"])
            date_created = fake.date_this_year()

            # Fix Insert Statement
            sql_pl = f"INSERT INTO PLAYLISTS (PLAYLIST_ID, USER_ID, PLAYLIST_TITLE, ISPUBLIC, ISCOLLABORATIVE, PLAYLIST_DESC, ISONPROFILE, PLAYLIST_DATE_CREATED) VALUES ({playlist_id_counter}, {u_id}, {escape_sql(pl_title)}, {is_public}, {is_collab}, {escape_sql(desc)}, {on_profile}, '{date_created}');"
            sql_statements.append(sql_pl)

            if valid_songs:
                picked_songs = random.sample(
                    valid_songs, k=random.randint(5, min(15, len(valid_songs)))
                )
                urutan = 1
                for s_id in picked_songs:
                    sql_add = f"INSERT INTO ADD_SONGS_PLAYLISTS (PLAYLIST_ID, SONG_ID, NO_URUT, USER_ID) VALUES ({playlist_id_counter}, {s_id}, {urutan}, {u_id});"
                    sql_statements.append(sql_add)
                    urutan += 1

            playlist_id_counter += 1

    # 6. LISTENS
    for _ in range(150):
        u_id = random.choice(valid_users)
        s_id = random.choice(valid_songs)
        dur = random.randint(30, 300)
        ts = fake.date_time_between(start_date="-1y", end_date="now")

        sql = f"INSERT INTO LISTENS (USER_ID, SONG_ID, DURATION_LISTENED, \"TIMESTAMP\") VALUES ({u_id}, {s_id}, {dur}, '{ts}');"
        sql_statements.append(sql)

    # 7. LIKE_SONGS & REVIEWS
    for u_id in valid_users:
        # Like Songs
        liked = random.sample(valid_songs, k=min(5, len(valid_songs)))
        for s_id in liked:
            sql = f"INSERT INTO LIKE_SONGS (USER_ID, SONG_ID) VALUES ({u_id}, {s_id}) ON CONFLICT DO NOTHING;"
            sql_statements.append(sql)

        # Reviews
        reviewed_cols = random.sample(
            valid_collections, k=min(2, len(valid_collections))
        )
        for c_id in reviewed_cols:
            rating = random.randint(1, 5) 
            txt = fake.sentence()
            sql = f"INSERT INTO REVIEWS (USER_ID, COLLECTION_ID, RATING, REVIEW) VALUES ({u_id}, {c_id}, {rating}, {escape_sql(txt)});"
            sql_statements.append(sql)

    # 8. FOLLOWS
    for u_id in valid_users:
        if valid_artists:
            fav_artists = random.sample(valid_artists, k=min(2, len(valid_artists)))
            for a_id in fav_artists:
                sql = f"INSERT INTO FOLLOW_ARTISTS (USER_ID, ARTIST_ID) VALUES ({u_id}, {a_id}) ON CONFLICT DO NOTHING;"
                sql_statements.append(sql)

        other_users = [x for x in valid_users if x != u_id]
        if other_users:
            follows = random.sample(other_users, k=min(2, len(other_users)))
            for friend_id in follows:
                sql = f"INSERT INTO FOLLOW_USERS (FOLLOWER_ID, FOLLOWED_ID) VALUES ({u_id}, {friend_id}) ON CONFLICT DO NOTHING;"
                sql_statements.append(sql)

    # ==========================================
    # --- PART 3: FITUR PELENGKAP (FULL DB) ---
    # ==========================================
    print("Generating Secondary Data (Tours, Socials, Blocks, Ratings)...")

    # 9. SOCIALS
    social_id_counter = 1
    for a_id in valid_artists:
        for _ in range(random.randint(1, 2)):
            platform = random.choice(["instagram", "twitter", "facebook", "tiktok"])
            link = f"https://{platform}.com/artist_{a_id}_{random.randint(100, 999)}"

            sql = f"INSERT INTO SOCIALS (SOCIAL_ID, ARTIST_ID, SOCIAL_MEDIA_LINK) VALUES ({social_id_counter}, {a_id}, {escape_sql(link)}) ON CONFLICT DO NOTHING;"
            sql_statements.append(sql)
            social_id_counter += 1

    # 10. TOURS & ARTISTS_TOURS
    tour_id_counter = 1
    for _ in range(5): 
        tour_name = f"{fake.city()} {random.choice(['Fest', 'Tour', 'Live', 'Concert'])} {fake.year()}"
        venue = fake.street_address()
        date = fake.date_this_year()

        sql = f"INSERT INTO TOURS (TOUR_ID, TOUR_DATE, TOUR_NAME, VENUE) VALUES ({tour_id_counter}, {escape_sql(date)}, {escape_sql(tour_name)}, {escape_sql(venue)});"
        sql_statements.append(sql)

        if valid_artists:
            lineup = random.sample(valid_artists, k=random.randint(1, 3))
            for a_id in lineup:
                sql_at = f"INSERT INTO ARTISTS_TOURS (TOUR_ID, ARTIST_ID) VALUES ({tour_id_counter}, {a_id}) ON CONFLICT DO NOTHING;"
                sql_statements.append(sql_at)
        
        tour_id_counter += 1

    # 11. RATE_SONGS
    for u_id in valid_users:
        rated_songs = random.sample(valid_songs, k=3)
        for s_id in rated_songs:
            rating = random.randint(50, 100) 
            sql = f"INSERT INTO RATE_SONGS (USER_ID, SONG_ID, SONG_RATING) VALUES ({u_id}, {s_id}, {rating}) ON CONFLICT DO NOTHING;"
            sql_statements.append(sql)

    # 12. LIBRARY
    print("Generating Library...")
    for u_id in valid_users:
        # Save Album
        if valid_collections:
            saved_col = random.sample(valid_collections, k=2)
            for c_id in saved_col:
                sql = f"INSERT INTO COLLECTION_LIBRARY (USER_ID, COLLECTION_ID) VALUES ({u_id}, {c_id}) ON CONFLICT DO NOTHING;"
                sql_statements.append(sql)

        # Save Playlist (PL_LIBRARY)
        if playlist_id_counter > 1:
            # Loop 3x percobaan biar dapet valid ID
            for _ in range(3):
                random_pl_id = random.randint(1, playlist_id_counter - 1)
                sql_pl = f"INSERT INTO PL_LIBRARY (USER_ID, PLAYLIST_ID) VALUES ({u_id}, {random_pl_id}) ON CONFLICT DO NOTHING;"
                sql_statements.append(sql_pl)

# ------------------------------------------
    # 14. BLOCKS (User & Artist) - GENERATE BANYAK
    # ------------------------------------------
    # Generate 5 blokir antar user
    if len(valid_users) >= 2:
        for _ in range(5):
            blocker = random.choice(valid_users)
            blocked = random.choice(valid_users)
            if blocker != blocked:
                sql = f"INSERT INTO BLOCK_USERS (BLOCKER_ID, BLOCKED_ID) VALUES ({blocker}, {blocked}) ON CONFLICT DO NOTHING;"
                sql_statements.append(sql)

    # Generate 5 blokir user ke artis
    if valid_users and valid_artists:
        for _ in range(5):
            u_id = random.choice(valid_users)
            a_id = random.choice(valid_artists)
            sql = f"INSERT INTO BLOCKLIST_ARTISTS (ARTIST_ID, USER_ID) VALUES ({a_id}, {u_id}) ON CONFLICT DO NOTHING;"
            sql_statements.append(sql)

    # ------------------------------------------
    # 15. LIKE REVIEWS - GENERATE BANYAK
    # ------------------------------------------
    # Asumsi kita punya beberapa review (Review ID Auto Increment)
    # Kita coba random insert like ke review ID 1 sampai 10 (jika ada)
    if valid_users:
        for _ in range(15): # 15 Likes random
            u_id = random.choice(valid_users)
            # Review ID kita tidak simpan di variable, tapi asumsi ada 1-20 review (dari loop Review sebelumnya)
            # Kita tebak aja ID review random kecil
            rev_id = random.randint(1, 15) 
            sql = f"INSERT INTO LIKE_REVIEWS (REVIEW_ID, USER_ID) VALUES ({rev_id}, {u_id}) ON CONFLICT DO NOTHING;"
            sql_statements.append(sql)

    # --- RESET SEQUENCES (PINDAH KE BAWAH) ---
    seq_tables = [
        "USERS", "ARTISTS", "GENRES", "COLLECTIONS", "SONGS", "REVIEWS", "PLAYLISTS", "SOCIALS", "TOURS"
    ]
    for t in seq_tables:
        sql = (
            f"SELECT setval('seq_{t.lower()}_id', (SELECT MAX({t[:-1]}_ID) FROM {t}));"
        )
        sql_statements.append(sql)

    # --- SAVE FILE (PINDAH KE BAWAH) ---
    # Ini yang paling penting, write file dilakukan SETELAH semua append selesai
    with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
        f.write("\n".join(sql_statements))

    print(f"ðŸŽ‰ Selesai! File '{OUTPUT_FILE}' siap dijalankan.")

if __name__ == "__main__":
    generate_data_safe()