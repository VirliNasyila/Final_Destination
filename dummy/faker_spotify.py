import os
import random
import spotipy
from dotenv import load_dotenv
from faker import Faker
from spotipy.oauth2 import SpotifyClientCredentials

# --- SETUP ENVIRONMENT ---
load_dotenv()
CLIENT_ID = os.getenv("SPOTIFY_CLIENT_ID")
CLIENT_SECRET = os.getenv("SPOTIFY_CLIENT_SECRET")
OUTPUT_FILE = "../database/02_dml_spotify.sql" # Nama file output baru

# Target berapa banyak Full Album yang mau diambil
TARGET_FULL_ALBUMS = 15 
# Target sisa lagu random (Singles/EP)
TARGET_RANDOM_TRACKS = 50 

# --- INIT ---
if not CLIENT_ID or not CLIENT_SECRET:
    print("‚ö†Ô∏è  WARNING: File .env tidak ditemukan atau kosong.")
    exit()

try:
    sp = spotipy.Spotify(
        auth_manager=SpotifyClientCredentials(
            client_id=CLIENT_ID, client_secret=CLIENT_SECRET
        )
    )
    print("‚úÖ Berhasil connect ke Spotify API")
except Exception as e:
    print(f"‚ùå Gagal connect ke Spotify: {e}")
    exit()

fake = Faker("id_ID")

def escape_sql(text):
    if text is None: return "NULL"
    text_str = str(text).replace("'", "''")
    return "'" + text_str + "'"

def get_safe_date(date_str):
    if not date_str or str(date_str).strip() == "": return "2020-01-01"
    parts = str(date_str).split("-")
    if parts[0] == "0000": return "2020-01-01"
    if len(parts) == 1: return f"{parts[0]}-01-01"
    if len(parts) == 2: return f"{parts[0]}-{parts[1]}-01"
    return date_str

def map_collection_type(spotify_type, total_tracks):
    st = spotify_type.lower()
    if "album" in st:
        return "Album"
    if "single" in st:
        return "Single" if total_tracks == 1 else "EP"
    if "compilation" in st: return "Compilation"
    return "EP"

def generate_data_safe():
    sql_statements = []

    # --- HEADER ---
    sql_statements.append("/* Script Generated by Python Faker + Spotipy (Full Albums Logic) */")
    sql_statements.append("BEGIN;")
    sql_statements.append("CREATE EXTENSION IF NOT EXISTS pgcrypto;")
    
    # CLEANUP
    sql_statements.append(
        """TRUNCATE TABLE 
        USERS, ARTISTS, GENRES, COLLECTIONS, SONGS, PLAYLISTS, 
        RELEASES, COLLECTIONS_SONGS, CREATE_SONGS, SONGS_GENRES, 
        FOLLOW_ARTISTS, FOLLOW_USERS, LISTENS, LIKE_SONGS, REVIEWS, 
        RATE_SONGS, TOURS, ARTISTS_TOURS, SOCIALS, COLLECTION_LIBRARY, 
        PL_LIBRARY, BLOCK_USERS, BLOCKLIST_ARTISTS, LIKE_REVIEWS, 
        ADD_SONGS_PLAYLISTS, COLLECTION_TOP_3_GENRES, ARTIST_PROMOTION 
        RESTART IDENTITY CASCADE;"""
    )

    # ==========================================
    # PHASE 1: FETCHING DATA (ALBUM ORIENTED)
    # ==========================================
    print("üîé Mencari Full Albums dari Spotify...")
    
    # Struktur data penampung: List of Dictionary
    # Item format: { "album_meta": album_obj, "tracks": [track_obj, track_obj...] }
    data_pool = []
    
    search_keywords = ["love", "blue", "night", "rock", "pop", "indonesia", "tulus", "coldplay", "jazz", "hits"]
    seen_album_ids = set()
    
    # 1. Fetch Full Albums (Prioritas Utama)
    attempts = 0
    while len(data_pool) < TARGET_FULL_ALBUMS and attempts < 50:
        keyword = random.choice(search_keywords)
        offset_val = random.randint(0, 50)
        
        try:
            # Cari Album, bukan Track
            results = sp.search(q=keyword, type="album", limit=20, offset=offset_val)
            albums = results["albums"]["items"]
            
            for album in albums:
                if album['id'] in seen_album_ids: continue
                
                # Logic: Hanya ambil jika tipe Album DAN total tracks > 5
                if album['album_type'] == 'album' and album['total_tracks'] > 5:
                    
                    # Ambil detail lagu dalam album ini
                    album_tracks_resp = sp.album_tracks(album['id'])
                    tracks = album_tracks_resp['items']
                    
                    data_pool.append({
                        "type": "ALBUM_FULL",
                        "album_meta": album,
                        "tracks": tracks
                    })
                    seen_album_ids.add(album['id'])
                    
                    if len(data_pool) >= TARGET_FULL_ALBUMS: break
                    
        except Exception as e:
            print(f"‚ö†Ô∏è API Skip (Album): {e}")
        attempts += 1
        
    print(f"‚úÖ Mendapatkan {len(data_pool)} Full Albums.")

    # 2. Fetch Random Singles/Mix (Supaya variatif)
    print("üîé Mencari lagu random tambahan...")
    random_tracks = []
    attempts = 0
    while len(random_tracks) < TARGET_RANDOM_TRACKS and attempts < 20:
        try:
            res = sp.search(q=random.choice(["a", "e", "i", "feat"]), type="track", limit=20)
            for item in res["tracks"]["items"]:
                if item['album']['id'] not in seen_album_ids:
                    # Format ulang biar sama dengan struktur data_pool
                    data_pool.append({
                        "type": "SINGLE_MIX",
                        "album_meta": item['album'],
                        "tracks": [item] # Cuma 1 lagu
                    })
                    seen_album_ids.add(item['album']['id'])
                    random_tracks.append(item)
                    if len(random_tracks) >= TARGET_RANDOM_TRACKS: break
        except: pass
        attempts += 1

    print(f"‚úÖ Total Collection yang akan diproses: {len(data_pool)}")

    # ==========================================
    # PHASE 2: INSERTING METADATA
    # ==========================================
    
    artist_map = {}      
    album_map = {}        
    genre_map = {}        
    artist_genres_temp = {} 
    artist_releases_map = {} 

    ids = {"users": 1, "artists": 1, "genres": 1, "collections": 1, "songs": 1}

    # --- 1. USERS ---
    print("Generasi Users...")
    for _ in range(50):
        u_name = fake.unique.user_name()
        email = f"{u_name}_{ids['users']}@example.com" 
        pfp = f"https://ui-avatars.com/api/?name={u_name}&background=random"
        raw_pw = fake.password(length=12)
        safe_pw = raw_pw.replace("'", "''")
        
        sql = f"INSERT INTO USERS (USER_ID, USERNAME, USER_EMAIL, PW_HASH, USER_PFP, REGION, COUNTRY) VALUES ({ids['users']}, {escape_sql(u_name)}, {escape_sql(email)}, crypt('{safe_pw}', gen_salt('bf')), {escape_sql(pfp)}, {escape_sql(fake.city())}, {escape_sql(fake.country())});"
        sql_statements.append(sql)
        ids["users"] += 1

    # --- 2. PROCESSING COLLECTIONS ---
    print("Processing Albums & Songs...")
    
    for entry in data_pool:
        sp_album = entry['album_meta']
        tracks_list = entry['tracks']
        
        # A. ARTIST & GENRES (Ambil dari Artist Album)
        sp_artist = sp_album["artists"][0] # Main artist of the album
        sp_artist_id = sp_artist["id"]
        db_artist_id = artist_map.get(sp_artist_id)

        if not db_artist_id:
            try: full_artist = sp.artist(sp_artist_id)
            except: continue 

            db_artist_id = ids["artists"]
            artist_map[sp_artist_id] = db_artist_id
            name = full_artist["name"][:250]
            pfp = full_artist["images"][0]["url"] if full_artist["images"] else ""
            
            sql = f"INSERT INTO ARTISTS (ARTIST_ID, ARTIST_NAME, ARTIST_PFP, MONTHLY_LISTENER_COUNT, ARTIST_EMAIL) VALUES ({db_artist_id}, {escape_sql(name)}, {escape_sql(pfp)}, {full_artist['followers']['total']}, 'contact.{db_artist_id}@label.com') ON CONFLICT DO NOTHING;"
            sql_statements.append(sql)
            ids["artists"] += 1

            # Genres
            temp_genres = []
            for g_name in full_artist["genres"]:
                temp_genres.append(g_name)
                if g_name not in genre_map:
                    g_id = ids["genres"]
                    genre_map[g_name] = g_id
                    sql_g = f"INSERT INTO GENRES (GENRE_ID, GENRE_NAME) VALUES ({g_id}, {escape_sql(g_name)}) ON CONFLICT DO NOTHING;"
                    sql_statements.append(sql_g)
                    ids["genres"] += 1
            artist_genres_temp[sp_artist_id] = temp_genres

        # B. COLLECTION
        db_album_id = ids["collections"]
        album_map[sp_album['id']] = db_album_id
        title = sp_album["name"][:250]
        date = get_safe_date(sp_album["release_date"])
        cover = sp_album["images"][0]["url"] if sp_album["images"] else ""
        total_tr = sp_album.get('total_tracks', len(tracks_list))
        
        sql = f"INSERT INTO COLLECTIONS (COLLECTION_ID, COLLECTION_TITLE, COLLECTION_TYPE, COLLECTION_RELEASE_DATE, COLLECTION_COVER, ISPRERELEASE) VALUES ({db_album_id}, {escape_sql(title)}, {escape_sql(map_collection_type(sp_album['album_type'], total_tr))}, {escape_sql(date)}, {escape_sql(cover)}, FALSE) ON CONFLICT DO NOTHING;"
        sql_statements.append(sql)
        ids["collections"] += 1

        # RELEASES
        sql_rel = f"INSERT INTO RELEASES (ARTIST_ID, COLLECTION_ID) VALUES ({db_artist_id}, {db_album_id}) ON CONFLICT DO NOTHING;"
        sql_statements.append(sql_rel)
        if db_artist_id not in artist_releases_map: artist_releases_map[db_artist_id] = []
        artist_releases_map[db_artist_id].append(db_album_id)

        # C. SONGS (Looping semua track dalam album ini)
        for track in tracks_list:
            if not track: continue
            
            db_song_id = ids["songs"]
            title = track["name"][:250]
            dur = int(track["duration_ms"] / 1000)
            file_path = track["preview_url"] if track.get("preview_url") else "/stream/audio_default.mp3"
            popularity = track.get("popularity", random.randint(10, 90)) # album_tracks endpoints kadang ga ada popularity
            
            # Insert Song
            sql = f"""INSERT INTO SONGS (SONG_ID, SONG_TITLE, SONG_DURATION, SONG_FILE, POPULARITY, VALENCE, ACCOUSTICNESS, DANCEABILITY, ENERGY, SONG_RELEASE_DATE) 
                      VALUES ({db_song_id}, {escape_sql(title)}, {dur}, {escape_sql(file_path)}, {popularity}, {round(random.random(),3)}, {round(random.random(),3)}, {round(random.random(),3)}, {round(random.random(),3)}, {escape_sql(date)}) ON CONFLICT DO NOTHING;"""
            sql_statements.append(sql)

            # Collection Songs
            sql_cs = f"INSERT INTO COLLECTIONS_SONGS (COLLECTION_ID, SONG_ID, NOMOR_DISC, NOMOR_TRACK) VALUES ({db_album_id}, {db_song_id}, {track['disc_number']}, {track['track_number']}) ON CONFLICT DO NOTHING;"
            sql_statements.append(sql_cs)

            # Create Songs (Link to Artist)
            sql_cr = f"INSERT INTO CREATE_SONGS (ARTIST_ID, SONG_ID) VALUES ({db_artist_id}, {db_song_id}) ON CONFLICT DO NOTHING;"
            sql_statements.append(sql_cr)

            # Song Genres (Inherit from Artist)
            assigned_genres = []
            if sp_artist_id in artist_genres_temp and artist_genres_temp[sp_artist_id]:
                assigned_genres = random.sample(artist_genres_temp[sp_artist_id], k=min(2, len(artist_genres_temp[sp_artist_id])))
            if not assigned_genres and genre_map:
                assigned_genres = random.sample(list(genre_map.keys()), k=min(2, len(genre_map)))

            for g_name in assigned_genres:
                if g_name in genre_map:
                    sql_sg = f"INSERT INTO SONGS_GENRES (SONG_ID, GENRE_ID) VALUES ({db_song_id}, {genre_map[g_name]}) ON CONFLICT DO NOTHING;"
                    sql_statements.append(sql_sg)
            
            ids["songs"] += 1

    # ==========================================
    # PART 3: INTERACTIONS (Same logic as before)
    # ==========================================
    print("Generating Interactions...")
    valid_users = list(range(1, ids["users"]))
    valid_songs = list(range(1, ids["songs"]))
    valid_cols = list(range(1, ids["collections"]))
    valid_arts = list(range(1, ids["artists"]))

    # Playlists
    pl_counter = 1
    if valid_users:
        for u_id in valid_users:
            for _ in range(random.randint(1, 2)):
                pl_title = fake.sentence(nb_words=3).replace(".", "")
                sql = f"INSERT INTO PLAYLISTS (PLAYLIST_ID, USER_ID, PLAYLIST_TITLE, ISPUBLIC, ISCOLLABORATIVE, PLAYLIST_DESC, ISONPROFILE, PLAYLIST_DATE_CREATED) VALUES ({pl_counter}, {u_id}, {escape_sql(pl_title)}, TRUE, FALSE, 'My generated playlist', TRUE, '{fake.date_this_year()}');"
                sql_statements.append(sql)
                if valid_songs:
                    songs_to_add = random.sample(valid_songs, k=min(len(valid_songs), random.randint(3, 8)))
                    for idx, s_id in enumerate(songs_to_add, 1):
                        sql_add = f"INSERT INTO ADD_SONGS_PLAYLISTS (PLAYLIST_ID, SONG_ID, NO_URUT, USER_ID) VALUES ({pl_counter}, {s_id}, {idx}, {u_id});"
                        sql_statements.append(sql_add)
                pl_counter += 1

    # Listens & Likes
    if valid_users and valid_songs:
        for _ in range(400):
            sql = f"INSERT INTO LISTENS (USER_ID, SONG_ID, DURATION_LISTENED, \"TIMESTAMP\") VALUES ({random.choice(valid_users)}, {random.choice(valid_songs)}, {random.randint(10,300)}, '{fake.date_time_between(start_date='-6m')}');"
            sql_statements.append(sql)
        for u in valid_users:
            for s in random.sample(valid_songs, k=min(len(valid_songs), 5)):
                sql_statements.append(f"INSERT INTO LIKE_SONGS (USER_ID, SONG_ID) VALUES ({u}, {s}) ON CONFLICT DO NOTHING;")
            for s in random.sample(valid_songs, k=min(len(valid_songs), 3)):
                sql_statements.append(f"INSERT INTO RATE_SONGS (USER_ID, SONG_ID, SONG_RATING) VALUES ({u}, {s}, {random.randint(1,100)}) ON CONFLICT DO NOTHING;")

    # Reviews
    total_reviews = 0
    if valid_users and valid_cols:
        for u in valid_users:
            for c in random.sample(valid_cols, k=min(len(valid_cols), random.randint(1, 2))):
                sql = f"INSERT INTO REVIEWS (USER_ID, COLLECTION_ID, RATING, REVIEW) VALUES ({u}, {c}, {random.randint(20,100)}, {escape_sql(fake.sentence())});"
                sql_statements.append(sql)
                total_reviews += 1
    if total_reviews > 0:
        for _ in range(40):
            sql_statements.append(f"INSERT INTO LIKE_REVIEWS (REVIEW_ID, USER_ID) VALUES ({random.randint(1, total_reviews)}, {random.choice(valid_users)}) ON CONFLICT DO NOTHING;")

    # Tours, Socials, Follows
    tour_cnt = 1
    for _ in range(5):
        sql = f"INSERT INTO TOURS (TOUR_ID, TOUR_DATE, TOUR_NAME, VENUE) VALUES ({tour_cnt}, '{fake.date_between(start_date='today', end_date='+1y')}', '{fake.city()} Tour', '{fake.company()} Arena');"
        sql_statements.append(sql)
        if valid_arts:
            for a in random.sample(valid_arts, k=min(len(valid_arts), random.randint(1,2))):
                sql_statements.append(f"INSERT INTO ARTISTS_TOURS (TOUR_ID, ARTIST_ID) VALUES ({tour_cnt}, {a}) ON CONFLICT DO NOTHING;")
        tour_cnt += 1
    
    if valid_arts:
        soc_cnt = 1
        for a in valid_arts:
             sql_statements.append(f"INSERT INTO SOCIALS (SOCIAL_ID, ARTIST_ID, SOCIAL_MEDIA_LINK) VALUES ({soc_cnt}, {a}, 'https://instagram.com/artist_{a}') ON CONFLICT DO NOTHING;")
             soc_cnt += 1

    if valid_users and valid_arts:
        for u in valid_users:
            for a in random.sample(valid_arts, k=min(len(valid_arts), 3)):
                sql_statements.append(f"INSERT INTO FOLLOW_ARTISTS (USER_ID, ARTIST_ID) VALUES ({u}, {a}) ON CONFLICT DO NOTHING;")
            targets = random.sample(valid_users, k=min(len(valid_users), 2))
            for t in targets:
                if u != t:
                     sql_statements.append(f"INSERT INTO FOLLOW_USERS (FOLLOWER_ID, FOLLOWED_ID) VALUES ({u}, {t}) ON CONFLICT DO NOTHING;")

    # Libraries & Promo
    if valid_users:
        for u in valid_users:
            if valid_cols:
                sql_statements.append(f"INSERT INTO COLLECTION_LIBRARY (USER_ID, COLLECTION_ID) VALUES ({u}, {random.choice(valid_cols)}) ON CONFLICT DO NOTHING;")
            if pl_counter > 2:
                sql_statements.append(f"INSERT INTO PL_LIBRARY (USER_ID, PLAYLIST_ID) VALUES ({u}, {random.randint(1, pl_counter-1)}) ON CONFLICT DO NOTHING;")

    for a_id, albums in artist_releases_map.items():
        if random.random() > 0.6 and albums:
            sql = f"INSERT INTO ARTIST_PROMOTION (ARTIST_ID, COLLECTION_ID, KOMENTAR_PROMOSI) VALUES ({a_id}, {random.choice(albums)}, 'Check my new stuff!') ON CONFLICT DO NOTHING;"
            sql_statements.append(sql)

    # Block
    if len(valid_users) > 5:
        for _ in range(5):
             u1, u2 = random.sample(valid_users, 2)
             sql_statements.append(f"INSERT INTO BLOCK_USERS (BLOCKER_ID, BLOCKED_ID) VALUES ({u1}, {u2}) ON CONFLICT DO NOTHING;")
    if valid_users and valid_arts:
        for _ in range(5):
             sql_statements.append(f"INSERT INTO BLOCKLIST_ARTISTS (ARTIST_ID, USER_ID) VALUES ({random.choice(valid_arts)}, {random.choice(valid_users)}) ON CONFLICT DO NOTHING;")

    # --- RESET SEQUENCES ---
    print("Resetting Sequences...")
    seq_tables = [
        "USERS", "ARTISTS", "GENRES", "COLLECTIONS", "SONGS", "REVIEWS", "PLAYLISTS", 
        "SOCIALS", "TOURS", "LISTENS", "ADD_SONGS_PLAYLISTS"
    ]
    for t in seq_tables:
        if t == "ADD_SONGS_PLAYLISTS": seq_name, col_id = "seq_add_songs_playlist_id", "ADD_SONG_PL_ID"
        else: seq_name, col_id = f"seq_{t.lower()}_id", f"{t[:-1]}_ID"
        sql = f"SELECT setval('{seq_name}', (SELECT MAX({col_id}) FROM {t}));"
        sql_statements.append(sql)

    sql_statements.append("COMMIT;")

    # --- SAVE ---
    with open(OUTPUT_FILE, "w", encoding="utf-8") as f:
        f.write("\n".join(sql_statements))
    print(f"üéâ Selesai! File '{OUTPUT_FILE}' siap. Total 27/27 Tabel terisi.")

if __name__ == "__main__":
    generate_data_safe()